#model
class MpesaPayments(models.Model):
    MPESA_PAYMENT_STATUS = [
        (1,"Pending"),
        (0,"Completed"),
    ]
    transaction_number = models.CharField(default=uuid.uuid4,max_length=55,unique=True)
    phone_number = PhoneNumberField()
    request_id = models.CharField(max_length=255)
    reference = models.CharField(max_length=50, blank=True)
    description = models.TextField(null=True, blank=True)
    amount = models.CharField(max_length=10)
    status = models.CharField(max_length=15, choices=MPESA_PAYMENT_STATUS, default=1)
    receipt_no = models.CharField(max_length=200, blank=True, null=True)
    ip = models.CharField(max_length=200, blank=True, null=True)
    confirmed = models.BooleanField(default=False)
    created = models.DateTimeField(auto_now_add=True)
    updated = models.DateTimeField(auto_now=True)
    
    def __unicode__(self):
        return f"{self.transaction_number}"

#views
import logging
from rest_framework.decorators import authentication_classes, permission_classes
from rest_framework.permissions import AllowAny
from rest_framework.response import Response
from rest_framework.views import APIView
from utilities_and_rent.serializers import MpesaPaySerializer
from utilities_and_rent.utils import MpesaGateWay

gateway = MpesaGateWay()

@authentication_classes([])
@permission_classes((AllowAny,))
class MpesaPay(APIView):
    serializer = MpesaPaySerializer
    
    def post(self, request, *args, **kwargs):
        serializer = self.serializer(data=request.data)
        if serializer.is_valid(raise_exception=True):
            payload = {"data":serializer.validated_data, "request":request}
            response = gateway.stk_push_request(payload)
            return Response(response, status=200)
        
@authentication_classes([])
@permission_classes((AllowAny,))
class MpesaCallBack(APIView):
    def get(self, request):
        return Response({"status": "OK"}, status=200)
    
    def post(self, request, *args, **kwargs):
        logging.info("{}".format("Callback from MPESA"))
        data = request.body
        return gateway.callback(json.loads(data))
    
#serializers
from utilities_and_rent.mpesa_validator import validate_possible_number
from rest_framework import serializers
from utilities_and_rent.models import MpesaPayments

from django.core.exceptions import ValidationError

class MpesaPaySerializer(serializers.ModelSerializer):
    class Meta:
        model = MpesaPayments
        fields = ['phone_number','amount','reference','description']
        
    def validate_phone_number(self,phone_number):
        if phone_number[0]=="+":
            phone_number = phone_number[1:]
        if phone_number[0] == "0":
            phone_number = "254" + phone_number[1:]
        try:
            validate_possible_number(phone_number,"KE")
        except ValidationError:
            raise serializers.ValidationError({"error":"invalid phone number"})
        
        return phone_number
    
    def amount_validation(self,amount):
        if not amount or float(amount)<=0:
            raise serializers.ValidationError({"error":"Can't process this amount"})
        return amount
    def reference_validation(self,reference):
        if reference:
            return reference
        return "Rental House Management System "
    def description_validation(self,description):
        if description:
            return description
        return "Rental House Management System Rent Payment"

class MpesaPaymentsSerializer(serializers.ModelSerializer):
    class Meta:
        model = MpesaPayments
        fields = "__all__"

#urls
    path('mpesa/pay/', views.MpesaPay.as_view(), name='mpesa_pay_now'),
    path('mpesa/callback/', views.MpesaCallBack.as_view(), name='call_back'),

#utils
import base64
import logging
import math
import time
from datetime import datetime

import requests
from config.settings import (ACCESS_TOKEN_URL, CALL_BACKS_URL,
                             MPESA_CONSUMER_KEY, MPESA_CONSUMER_SECRET,
                             MPESA_PASS_KEY, MPESA_SHORTCODE, STK_PUSH_URL)
from phonenumber_field.phonenumber import PhoneNumber
from requests.auth import HTTPBasicAuth
from rest_framework.response import Response

from utilities_and_rent.models import MpesaPayments
from utilities_and_rent.serializers import MpesaPaySerializer, MpesaPaymentsSerializer
logging = logging.getLogger("default")


class MpesaGateWay:
    shortcode = None
    consumer_key = None
    consumer_secret = None
    access_token_url = None
    access_token = None
    access_token_expiration = None
    stk_push_url = None
    timestamp = None
    
    
    def __init__(self):
        now = datetime.now()
        self.shortcode = MPESA_SHORTCODE
        self.consumer_key = MPESA_CONSUMER_KEY
        self.consumer_secret = MPESA_CONSUMER_SECRET
        self.access_token_url = ACCESS_TOKEN_URL
        self.password = self.generate_password()
        self.callback_url = CALL_BACKS_URL
        self.stk_push_url = STK_PUSH_URL
        
        try:
            self.access_token = self.get_access_token()
            if self.access_token is None:
                raise Exception("Request for access token failed.")
        except Exception as e:
            logging.error("Error {}".format(e))
        else:
            self.access_token_expiration = time.time()+3400
            
    def get_access_token(self):
        try:
            response = requests.get(self.access_token_url,
                auth=HTTPBasicAuth(self.consumer_key,self.consumer_secret),
                )
        except Exception as exc:
            logging.error("Error {}".format(exc))
            raise exc
        else:
            token = response.json()['access_token']
            self.headers = {'Authorization': "Bearer %s" % token}
            return token
    
    class Decorators:
        @staticmethod
        def refresh_token(decorated):
            def wrapper(gateway,*args, **kwargs):
                if (gateway.access_token_expiration and time.time() > gateway.access_token_expiration):
                    token = gateway.get_access_token()
                    gateway.access_token = token
                return decorated(gateway,*args,**kwargs)
            return wrapper
    
    def generate_password(self):
        self.timestamp = time.strftime("%Y%m%d%H%M%S")
        password_str = MPESA_SHORTCODE+MPESA_PASS_KEY+self.timestamp 
        password_bytes = password_str.encode('ascii')
        return base64.b64encode(password_bytes).decode("utf-8")
    
    @Decorators.refresh_token
    def stk_push_request(self,payload):
        request = payload['request']
        data = payload['data']
        amount = data['amount']
        phone_number = data['phone_number']
        
        request_data = {
            "BusinessShortCode": self.shortcode, "Password": self.password, "Timestamp": self.timestamp,
            "TransactionType": "CustomerPayBillOnline", "Amount": math.ceil(float(amount)),
            "PartyA": phone_number, "PartyB": self.shortcode, "PhoneNumber": phone_number,
            "CallBackURL": self.callback_url, "AccountReference": "Test", "TransactionDesc": "Test",
        }
        response = requests.post(self.stk_push_url,json=request_data,headers=self.headers,timeout=30)
        response_data = response.json()
        logging.info("Mpesa request data {}".format(request_data))
        logging.info("Mpesa response info {}".format(response_data))
        
        if response.ok:
            data['ip'] = request.META.get('REMOTE_ADDR')
            data['request_id'] = response_data['CheckoutRequestID']
            MpesaPayments.objects.create(**data)
        return response_data
    
    def check_status(self,data):
        try:
            status = data["Body"]["stkCallback"]["ResultCode"]
        except Exception as e:
            logging.error(f"Error: {e}")
            status = 1
        return status
    def get_transaction_object(data):
        request_id = data["Body"]["stkCallback"]["CheckoutRequestID"]
        pay_object = MpesaPayments.objects.get_or_create(
            request_id=request_id,
        )
        return pay_object
    def success(self, data, pay_object):
        items = data["Body"]["stkCallback"]["CallbackMetadata"]["Item"]
        for item in items:
            if item["Name"] == "Amount":
                amount = item["Value"]
            elif item["Name"] == "MpesaReceiptNumber":
                receipt_no = item["Value"]
            elif item["Name"] == "PhoneNumber":
                phone_number = item["Value"]
        
        pay_object.amount = amount
        pay_object.phone_number = PhoneNumber(raw_input=phone_number)
        pay_object.receipt_no = receipt_no
        pay_object.confirmed = True
        return pay_object
    
    def callack_handler(self,data):
        status = self.check_status(data)
        pay_object = self.get_transaction_object(data)
        if status == 0:
            self.success(data,pay_object)
        else:
            pay_object.status = 1
        pay_object.status = status
        pay_object.save()
        
        
        pay_data = MpesaPaymentsSerializer(pay_object).data
        logging.info("Transaction completed {}".format(pay_data))
        return Response({"status": "ok", "code": 0}, status=200)

#validator
from enum import Enum
from django.core.exceptions import ValidationError
from phonenumber_field.phonenumber import to_python
from phonenumbers.phonenumberutil import is_possible_number
#from utilities_and_rent.mpesa_error_codes import PaymentErrorCode

class PaymentErrorCode(Enum):
    INVALID = "invalid_phone"
    PAYMENT_ERROR = "payment_error"
    

def validate_possible_number(phone, country=None):
    phone_number = to_python(phone, country)
    if (
        phone_number
        and not is_possible_number(phone_number)
        or not phone_number.is_valid()
    ):
        raise ValidationError(
            "The phone number entered is not valid.", code=PaymentErrorCode.INVALID
        )
    return phone_number

